{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"SQLAlchemy Filter","text":"<p>Package for convenient filtration and ordering functionality in SQLAlchemy</p> <p>Quite often, optional filtration functionality is required. To facilitate the implementation of filtration functionality, this package was written</p> <p>Features:</p> <ul> <li>filtration:<ul> <li>relationships</li> <li>\"or\" filtration</li> <li>manual filtration</li> </ul> </li> <li>ordering</li> </ul>"},{"location":"changelog/","title":"Changelog","text":""},{"location":"changelog/#055-2025-07-27","title":"0.5.5 (2025-07-27)","text":""},{"location":"changelog/#054-2025-07-27","title":"0.5.4 (2025-07-27)","text":""},{"location":"changelog/#053-2025-07-21","title":"0.5.3 (2025-07-21)","text":""},{"location":"changelog/#fix","title":"Fix","text":"<ul> <li>return SelectClause</li> </ul>"},{"location":"changelog/#052-2025-07-21","title":"0.5.2 (2025-07-21)","text":""},{"location":"changelog/#051-2025-07-21","title":"0.5.1 (2025-07-21)","text":""},{"location":"changelog/#fix_1","title":"Fix","text":"<ul> <li>return generic to stmt, upgrade mypy</li> </ul>"},{"location":"changelog/#050-2025-07-21","title":"0.5.0 (2025-07-21)","text":"<ul> <li>support ManualFilter</li> </ul>"},{"location":"changelog/#041-2025-06-04","title":"0.4.1 (2025-06-04)","text":""},{"location":"changelog/#040-2025-06-04","title":"0.4.0 (2025-06-04)","text":""},{"location":"changelog/#feat","title":"Feat","text":"<ul> <li>support OR filter</li> </ul>"},{"location":"changelog/#032-2025-02-19","title":"0.3.2 (2025-02-19)","text":""},{"location":"changelog/#031-2025-01-27","title":"0.3.1 (2025-01-27)","text":""},{"location":"changelog/#030-2025-01-27","title":"0.3.0 (2025-01-27)","text":""},{"location":"changelog/#feat_1","title":"Feat","text":"<ul> <li>Impl ordering feature</li> </ul>"},{"location":"installation/","title":"Installation","text":"pip install sqla-filterInstalled"},{"location":"ordering/","title":"Ordering","text":"<pre><code>from typing import Annotated, Any\n\nfrom sqlalchemy import Select, select\n\nfrom examples.models import Author, Book, User\nfrom sqla_filter import (\n    UNSET,\n    BaseSorter,\n    OrderingEnum,\n    OrderingField,\n    RelationshipInfo,\n    Unset,\n)\nfrom sqla_filter.ordering import build_priorities\n\n\nclass BookSorter(BaseSorter):\n    created_at: Annotated[OrderingEnum | Unset, OrderingField(Book.created_at)] = UNSET\n    author_user_first_name: Annotated[\n        OrderingEnum | Unset,\n        OrderingField(\n            User.first_name,\n            relationships=[\n                RelationshipInfo(field=Book.authors),\n                RelationshipInfo(field=Author.user),\n            ],\n        ),\n    ] = UNSET\n    author_user_last_name: Annotated[\n        OrderingEnum | Unset,\n        OrderingField(\n            User.last_name,\n            relationships=[\n                RelationshipInfo(field=Book.authors),\n                RelationshipInfo(field=Author.user),\n            ],\n        ),\n    ] = UNSET\n    author_user_last_name_nulls_last: Annotated[\n        OrderingEnum | Unset,\n        OrderingField(\n            User.last_name,\n            relationships=[\n                RelationshipInfo(field=Book.authors),\n                RelationshipInfo(field=Author.user),\n            ],\n        ),\n        nulls=\"last\",\n    ] = UNSET\n    author_user_is_deleted: Annotated[\n        OrderingEnum | Unset,\n        OrderingField(\n            User.is_deleted,\n            relationships=[\n                RelationshipInfo(field=Book.authors),\n                RelationshipInfo(field=Author.user),\n            ],\n        ),\n    ] = UNSET\n\n\ndef main() -&gt; None:\n    stmt = select(Book)\n    print_stmt(stmt)\n\n    sorter = BookSorter(\n        author_user_last_name=OrderingEnum.desc,\n        created_at=OrderingEnum.desc,\n        author_user_is_deleted=OrderingEnum.desc,\n    )\n\n    stmt = sorter.apply(\n        stmt,\n        fields_priority=build_priorities(\n            BookSorter.author_user_is_deleted,\n            BookSorter.author_user_last_name,\n        ),\n    )\n</code></pre>"},{"location":"ordering/#important-note","title":"Important note","text":"<p>Only pass fields of a class that extends the BaseSorter class to <code>build_priorities</code>.</p>"},{"location":"philosophy/","title":"Philosophy","text":"<p>The following models are available</p> <pre><code>class Review(Base):\n    __tablename__ = \"review\"\n\n    id: Mapped[uuid.UUID] = mapped_column(primary_key=True, default=uuid.uuid4)\n    content: Mapped[str]\n    book_id: Mapped[uuid.UUID] = mapped_column(ForeignKey(\"book.id\"))\n    user_id: Mapped[uuid.UUID] = mapped_column(ForeignKey(\"user.id\"))\n\n\nclass Author(Base):\n    __tablename__ = \"author\"\n\n    id: Mapped[uuid.UUID] = mapped_column(primary_key=True, default=uuid.uuid4)\n\n\nclass BookAuthor(Base):\n    __tablename__ = \"book__author\"\n\n    book_id: Mapped[uuid.UUID] = mapped_column(ForeignKey(\"book.id\"), primary_key=True)\n    author_id: Mapped[uuid.UUID] = mapped_column(\n        ForeignKey(\"author.id\"),\n        primary_key=True,\n    )\n\n\nclass Book(Base):\n    __tablename__ = \"book\"\n\n    id: Mapped[uuid.UUID] = mapped_column(primary_key=True, default=uuid.uuid4)\n    authors: Mapped[list[Author]] = relationship(secondary=BookAuthor.__table__)\n    reviews: Mapped[list[Review]] = relationship()\n    created_at: Mapped[datetime]\n</code></pre> <p>Most often, filtering objects looks like this</p> <pre><code>@dataclass(frozen=True, slots=True)\nclass BookFilter:\n    ident: UUID | None = None\n    created_at_from: datetime | None = None\n    created_at_to: datetime | None = None\n\n    author_ids: Sequence[UUID] | None = None\n    review_ids: Sequence[UUID] | None = None\n\n    review_content_contains: str | None = None\n</code></pre> <pre><code>class BookRepository:\n    ...\n\n    async def get_list(self, filter_: BookFilter) -&gt; Sequence[Book]:\n        stmt = select(Book)\n\n        if filter_.ident is not None:\n            stmt = stmt.where(Book.id == filter_.ident)\n        if filter_.created_at_from is not None:\n            stmt = stmt.where(Book.created_at &gt;= filter_.created_at_from)\n        if filter_.created_at_to is not None:\n            stmt = stmt.where(Book.created_at &lt;= filter_.created_at_to)\n        if filter_.author_ids is not None:\n            stmt = stmt.join(Book.authors).where(Author.id.in_(filter_.author_ids))\n        if filter_.review_ids is not None:\n            stmt = stmt.join(Book.reviews).where(Review.id.in_(filter_.review_ids))\n\n        return (await self._session.scalars(stmt)).all()\n</code></pre> <p>Not everyone is happy with such code in repository methods. Therefore, there was an attempt to reduce the code in repositories. Of course, not without victims. Now there is more code in filter classes.</p> <pre><code>from sqlalchemy.sql.operators import eq, ge, icontains_op, in_op, le\nfrom sqla_filter import (\n    BaseFilter,\n    Unset,\n    UNSET,\n    FilterField,\n    RelationshipInfo,\n)\n\n\nclass BookFilter(BaseFilter):\n    ident: Annotated[UUID | Unset, FilterField(Book.id, operator=eq)] = UNSET\n\n    created_at_from: Annotated[\n        datetime | Unset,\n        FilterField(Book.created_at, operator=ge),\n    ] = UNSET\n    created_at_to: Annotated[\n        datetime | Unset,\n        FilterField(Book.created_at, operator=le),\n    ] = UNSET\n\n    author_ids: Annotated[\n        Sequence[UUID] | Unset,\n        FilterField(\n            Author.id,\n            operator=in_op,\n            relationship=RelationshipInfo(field=Book.authors),\n        ),\n    ] = UNSET\n    review_ids: Annotated[\n        list[UUID] | Unset,\n        FilterField(\n            Review.id,\n            operator=in_op,\n            relationship=RelationshipInfo(field=Book.reviews),\n        ),\n    ] = UNSET\n\n    review_content_contains: Annotated[\n        str | Unset,\n        FilterField(\n            Review.content,\n            operator=icontains_op,\n            relationship=RelationshipInfo(field=Book.reviews),\n        ),\n    ] = UNSET\n</code></pre> <p>But on the other hand, the code in the repository methods has become cleaner.</p> <pre><code>class BookRepository:\n    ...\n\n    async def get_list(self, filter_: BookFilter) -&gt; Sequence[Book]:\n        stmt = select(Book)\n        stmt = filter_.apply(stmt)\n        return (await self._session.scalars(stmt)).all()\n</code></pre> <p>The choice is yours \ud83e\udd17</p>"},{"location":"filtering/manual_filter/","title":"Manual Filter","text":"<p>Sometimes you need some filtering. For this there is <code>sqla_filter.filter_.ManualFilter</code>.</p> <pre><code># manual_filter.py\n\nfrom typing import TYPE_CHECKING, final\n\nfrom sqlalchemy import Select, exists, not_, select\n\nfrom examples.models import Contract, ContractJob, Job\nfrom sqla_filter.filter_ import ManualFilter\nfrom sqla_filter.unset import define\n\nif TYPE_CHECKING:\n    from manual_filter_example import ContractFilter\n\n\n@final\nclass HasUrgentJobFilter(ManualFilter[tuple[Contract], \"ContractFilter\"]):\n    def apply(\n        self,\n        stmt: Select[tuple[Contract]],\n        *,\n        value: bool,\n        filter_: \"ContractFilter\",\n    ) -&gt; Select[tuple[Contract]]:\n        urgent_specs_exists = exists(\n            select(1)\n            .select_from(ContractJob)\n            .join(\n                Job,\n                ContractJob.job_id == Job.id,\n            )\n            .where(\n                ContractJob.contract_id == define(filter_.ident),\n                Job.is_urgent.is_(other=True),\n            ),\n        )\n\n        condition = urgent_specs_exists if define(value) else not_(urgent_specs_exists)\n        return stmt.where(condition)\n</code></pre> <pre><code># manual_filter_example.py\n\nimport uuid\nfrom operator import eq\nfrom typing import Annotated\nfrom uuid import UUID\n\nfrom sqlalchemy import select\n\nfrom sqla_filter.base import BaseFilter\nfrom sqla_filter.filter_ import FilterField\nfrom sqla_filter.unset import UNSET, Unset\n\nfrom .manual_filter import HasUrgentJobFilter\n\n\nclass ContractFilter(BaseFilter):\n    ident: Annotated[UUID | Unset, FilterField(Contract.id, operator=eq)] = UNSET\n    has_urgent_job: Annotated[bool | Unset, HasUrgentJobFilter()] = UNSET\n</code></pre> <p>You may not want the filter to be automatically applied. To do this, you must not apply <code>Annotated</code></p> <pre><code>class SomeFilter(BaseFilter):\n    ident: Annotated[UUID | Unset, FilterField(SomeModel.id, operator=eq)] = UNSET\n    other_id: UUID | None = None\n\n\nclass Repository:\n    ...\n\n    async def get(self, filter_: SomeFilter) -&gt; SomeModel | None:\n        stmt = select(SomeModel)\n        stmt = filter_.apply(stmt)\n\n        if (other_id := filter_.other_id) is not None:\n            stmt = stmt.where(SomeModel.other_id == other_id)\n        ...\n</code></pre>"},{"location":"filtering/or_filter/","title":"Or Filter","text":"<pre><code>from sqla_filter import (\n    UNSET,\n    FilterField,\n    SupportsOrFilter,\n    Unset,\n)\n\nclass BookOrFilter(SupportsOrFilter):\n    ident: Annotated[UUID | Unset, FilterField(Book.id, operator=eq)] = UNSET\n\n\ndef main() -&gt; None:\n    stmt = select(Book)\n\n    filter_ = BookOrFilter(\n        ident=UUID(\"11111111-1111-1111-1111-111111111111\"),\n        or_=BookOrFilter(ident=UUID(\"00000000-0000-0000-0000-000000000001\")),\n    )\n\n    stmt = filter_.apply(stmt)\n</code></pre>"},{"location":"filtering/relationships/","title":"Relationships","text":""},{"location":"filtering/relationships/#models-example","title":"Models example","text":"<pre><code>class User(Base):\n    __tablename__ = \"user\"\n\n    id: Mapped[uuid.UUID] = mapped_column(primary_key=True, default=uuid.uuid4)\n\n\nclass Author(Base):\n    __tablename__ = \"author\"\n\n    id: Mapped[uuid.UUID] = mapped_column(primary_key=True, default=uuid.uuid4)\n    last_name: Mapped[str]\n    first_name: Mapped[str]\n    user: Mapped[User] = relationship()\n\n\nclass BookAuthor(Base):\n    __tablename__ = \"book__author\"\n\n    book_id: Mapped[uuid.UUID] = mapped_column(ForeignKey(\"book.id\"), primary_key=True)\n    author_id: Mapped[uuid.UUID] = mapped_column(\n        ForeignKey(\"author.id\"),\n        primary_key=True,\n    )\n\n\nclass Book(Base):\n    __tablename__ = \"book\"\n\n    id: Mapped[uuid.UUID] = mapped_column(primary_key=True, default=uuid.uuid4)\n    authors: Mapped[list[Author]] = relationship(secondary=BookAuthor.__table__)\n    created_at: Mapped[datetime]\n</code></pre>"},{"location":"filtering/relationships/#relationship","title":"Relationship","text":"<p>Don't worry if you specify more than one of the same relationship field. If you use join via relationship, the join will only happen once.</p> <pre><code>class BookFilter(BaseFilter):\n    author_last_name_contains: Annotated[\n        list[UUID] | Unset,\n        FilterField(\n            Author.last_name,\n            operator=icontains_op,\n            relationship=RelationshipInfo(field=Book.authors),\n        ),\n    ] = UNSET\n    author_first_name_contains: Annotated[\n        list[UUID] | Unset,\n        FilterField(\n            Author.first_name,\n            operator=icontains_op,\n            relationship=RelationshipInfo(field=Book.authors),\n        ),\n    ] = UNSET\n</code></pre>"},{"location":"filtering/relationships/#nested-relationships","title":"Nested relationships","text":"<p>If you have a deeper join, you can use the <code>relationships</code> parameter</p> <pre><code>class BookFilter(BaseFilter):\n  author_user_id: Annotated[\n        UUID | Unset,\n        FilterField(\n            User.id,\n            operator=eq,\n            relationships=[\n                RelationshipInfo(field=Book.authors),\n                RelationshipInfo(field=Author.user),\n            ],\n        ),\n    ] = UNSET\n</code></pre>"},{"location":"filtering/simple_usage/","title":"Simple Usage","text":"<pre><code># models.py\nclass Review(Base):\n    __tablename__ = \"review\"\n\n    id: Mapped[uuid.UUID] = mapped_column(primary_key=True, default=uuid.uuid4)\n    content: Mapped[str]\n</code></pre> <p>Define filter class</p> <pre><code># filters.py\n\nfrom operator import eq\nfrom sqla_filter import (\n    BaseFilter,\n    Unset,\n    UNSET,\n    FilterField,\n)\n\nfrom db.models import Review\n\nclass ReviewFilter(BaseFilter):\n    ident: Annotated[UUID | Unset, FilterField(Review.id, operator=eq)] = UNSET\n    content: Annotated[\n        str | Unset,\n        FilterField(Review.content, operator=eq),\n    ] = UNSET\n</code></pre> <p>Use a filter in the repository (or elsewhere)</p> <pre><code># repository.py\n\nclass ReviewRepository:\n    def __init__(self, session: AsyncSession) -&gt; None:\n        self._session = session\n\n    async def get(self, filter_: ReviewFilter) -&gt; Review | None:\n        stmt = select(ReviewFilter)\n        stmt = filter_.apply(stmt)\n        return (await self._session.scalars()).one_or_none()\n</code></pre> <p>Use repository method</p> <pre><code># command.py\n\nclass UpdateReviewCommand:\n    def __init__(self, repository: ReviewRepository) -&gt; None:\n        self._repository = repository\n\n    async def execute(self, ident: UUID, content: str) -&gt; Review:\n        review = await self._repository.get(\n            filter_=ReviewFilter(ident=ident)\n        )\n        ...\n</code></pre>"}]}